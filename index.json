[{"categories":null,"content":"Android Develper Work in Zhengzhou Github LeetCode StackOverflow ","date":"2020-09-03","objectID":"https://yangfengfan.dev/about/:0:0","tags":null,"title":"About","uri":"https://yangfengfan.dev/about/"},{"categories":["Java"],"content":"1、Error Error类是指java运行时系统内部错误和资源耗尽错误。应用程序不会抛出该类对象，如果出现了这样的错误 ，除了告知用户，剩下的就是尽力使应用程序的终止。 ","date":"2019-05-14","objectID":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/:1:0","tags":["Java"],"title":"Java异常处理","uri":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"2、Exception Exception又有两个分支，运行时异常RuntimeException和检查异常CheckException ","date":"2019-05-14","objectID":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/:2:0","tags":["Java"],"title":"Java异常处理","uri":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"2.1、RuntimeException 如：NullPointerException、ClassCastException；运行时异常那些可能在java虚拟机正常运行期间抛出的异常的超类，如果出现运行时异常那么一定是程序员的错误。 ","date":"2019-05-14","objectID":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/:2:1","tags":["Java"],"title":"Java异常处理","uri":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"2.2、CheckedException 如：IOException、SQLException；一般是外部错误，这种异常都可能发生在编译阶段，Java编译器会强制程序去捕获这些异常，即会要求你把这段可能出现异常的程序进行try-catch。 ","date":"2019-05-14","objectID":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/:2:2","tags":["Java"],"title":"Java异常处理","uri":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"3、异常处理方式 抛出异常有三种方式，一种是throw、一种是throws、还有一种系统自动抛出异常 throw和throws的区别 ","date":"2019-05-14","objectID":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/:3:0","tags":["Java"],"title":"Java异常处理","uri":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"3.1、位置不同 throws作用在函数上，后面跟的是异常类，可以跟多个；而throw用在函数内，后面跟的是异常对象。 ","date":"2019-05-14","objectID":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/:3:1","tags":["Java"],"title":"Java异常处理","uri":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"3.2、功能不同 throws用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw抛出问题的具体对象，代码执行到throw就结束了，功能就结束了，跳转到调用者，并将具体的问题对象抛给调用者，也就是说throw语句独立存在时，下面不要定义其他语句，因为执行不到。 throws表示出现异常的一种可能性，并不一定会发生这些异常；throws则是抛出了异常，执行throw则一定抛出了某种异常对象 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常都是由异常函数的上层调用处理。 ","date":"2019-05-14","objectID":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/:3:2","tags":["Java"],"title":"Java异常处理","uri":"https://yangfengfan.dev/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"},{"categories":["Android"],"content":"1.Activity生命周期 ","date":"2019-05-07","objectID":"https://yangfengfan.dev/activity%E5%92%8Cfragment%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:1:0","tags":["Android"],"title":"Activity和Fragment的生命周期","uri":"https://yangfengfan.dev/activity%E5%92%8Cfragment%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"categories":["Android"],"content":"2.Fragment生命周期 创建Fragment onAttach() —\u003e onCreate() —\u003e onCreateView() —\u003e onActivityCreated() —\u003e onStart() —\u003e onResume() 按下Home键回到桌面 / 锁屏 onPause() —\u003e onStop() 从桌面回到Fragment / 解锁 onStart() —\u003e onResume() 切换到其他Fragment onPause() —\u003e onStop() —\u003e onDestroyView() 切换回本身的Fragment onCreateView() —\u003e onActivityCreated() —\u003e onStart() —\u003e onResume() 按下Back键退出 onPause() —\u003e onStop() —\u003e onDestroyView() —\u003e onDestroy() —\u003e onDetach() ","date":"2019-05-07","objectID":"https://yangfengfan.dev/activity%E5%92%8Cfragment%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:2:0","tags":["Android"],"title":"Activity和Fragment的生命周期","uri":"https://yangfengfan.dev/activity%E5%92%8Cfragment%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"categories":["Android"],"content":"2.1 onCreateView与onViewCreated的区别 onViewCreated在onCreateView执行完后立即调用， onCreateView() –\u003e onViewCreated() 为什么要分开： 一般在onCreateView中设置布局，但是在onCreateView使用findViewById的是否布局可能没有完全加载成功，所以可能会出现闪退。onViewCreated()是在onCreateView()执行完成后调用的，也就是布局加载成功后，所以在这里面使用findViewById就不会出现问题。 参考：https://stackoverflow.com/questions/25119090/difference-between-oncreateview-and-onviewcreated-in-fragment ","date":"2019-05-07","objectID":"https://yangfengfan.dev/activity%E5%92%8Cfragment%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:3:0","tags":["Android"],"title":"Activity和Fragment的生命周期","uri":"https://yangfengfan.dev/activity%E5%92%8Cfragment%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"categories":[],"content":"标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 效果： 一级标题 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:1:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"二级标题 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:2:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"三级标题 四级标题 五级标题 六级标题 列表 无序列表 * 无序列表1 * 子项1 * 子项1 + 无序列表2 + 子项2 + 子项2 - 无序列表3 - 子项3 - 子项3 效果： 无序列表1 子项1 子项1 无序列表2 子项2 子项2 无序列表3 子项3 子项3 有序列表 1. 第一行 2. 第二行 3. 第三行 效果： 第一行 第二行 第三行 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:2:1","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"引用 \u003e 引用 \u003e\u003e 引用嵌套 \u003e\u003e\u003e\u003e 可以无限嵌套 效果： 引用 引用嵌套 可以无限嵌套 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:3:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"分割线 *** --- ___ 效果： ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:4:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"链接 [This link](https://yangfengfan.dev) has no title attribute. This is [an example](https://yangfengfan.dev \"Title\") inline link. 效果： This link has no title attribute. This is an example inline link. ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:5:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"自动链接 \u003chttps://yangfengfan.dev/\u003e \u003cyangfengfandev@gmail.com\u003e 效果： https://yangfengfan.dev/ yangfengfandev@gmail.com ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:6:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"强调 single asterisks *single asterisks* single underscores _single underscores_ double asterisk **double asterisks** double underscores __double underscores__ 效果： single asterisks single asterisks single underscores single underscores double asterisk double asterisks double underscores double underscores ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:7:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"代码 `printf()` ``` printf()； printf()； ``` 效果： printf() printf()； printf()； ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:8:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"图片 ![提示信息](/images/2019/04/24/1.png) ![Alt text](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1313983748,591596023\u0026fm=26\u0026gp=0.jpg) 效果： ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:9:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"转义字符 \\\\ 反斜线 \\` 反引号 \\* 星号 \\_ 底线 \\{} 花括号 \\[] 方括号 \\() 括弧 \\# 井字号 \\+ 加号 \\- 减号 \\. 英文句点 \\! 惊叹号 效果: \\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/:10:0","tags":["Markdown"],"title":"Markdown语法","uri":"https://yangfengfan.dev/markdown%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"时光穿梭机 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:1:0","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"版本回退 相对回退 如果要回到上一个版本使用 git reset --hard HEAD^,回到上上一个版本使用 git reset --hard HEAD^^ 一个^表示向前回退一次，如果回退到十次前可以使用 git reset --hard HEAD～10. 回退到特定的提交点 使用 git log 可以查看commit提交记录，每次提交都会有一串很长的版本号，比如__332ef74ebabae2afa0ff671e8998d7df7bef2faf__, 使用 git reseet --hard \u003ccommit id\u003e, 比如 git reset --hard 332ef74ebabae2afa0ff671e8998d7df7bef2faf， 我们可以不用这么麻烦，再commit id前几位不冲突的情况下我们可以实用简写，比如目前所有的commit id前四位都是不同的， 我们就可以使用 git reset --hard 332e。 回退到未来 假如仓库提交的顺序为A-B-C，目前位于C，我们回退到了B，但是想要再回到C。 此时使用 git log 只会显示A-B的commit id, 如果想知道C的commit就要使用 git reflog来显示所有提交过得commit id, 再通过 git reset --hard \u003ccommmit id\u003e 就可以回到 C 了。 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:1:1","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"撤销修改 修改后还没有add 如果没有add可以直接ctrl+Z,返回到原来的样子。但是我们要使用Git，git checkout -- \u003cfilename\u003e舍弃修改的变动。 已经add到了暂存区 如果已经add到了暂存区，使用 git reset HEAD \u003cfilename\u003e这样只是撤销add，也就是把暂存区的文件回退到工作区，但是更改的文件还是没有回到原来的状态，再使用git checkout -- \u003cfilename\u003e舍弃变动。 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:1:2","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"撤销删除 还没有add 如果在编译器中直接把文件删除了，在没有add的情况下使用 git checkout -- \u003c文件名\u003e 可以撤销删除。 已经add了 如果已经add到了暂存区，使用 git reset HEAD \u003cfilename\u003e 来撤销提交，最后使用git checkout -- \u003cfilename\u003e 来撤销删除。 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:1:3","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"远程仓库 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:2:0","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"关联到远程仓库 使用 git remote add origion \u003cgit仓库地址\u003e， 就可以把本地仓库关联到远程仓库 第一次提交使用 git push -u origion master， 这样会把本地的master分支和远程仓库master分支关联， 以后再提交的话可以使用 git push 就可以了。 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:2:1","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"从远程仓库克隆 git clone \u003c仓库地址\u003e ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:2:2","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"分支管理 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:3:0","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"创建并切换分支 查看当前分支 git branch 创建新分支 git branch \u003c分支名\u003e 删除分支 git branch -d \u003c分支名\u003e 强制删除分支 git branch -D \u003c分支名\u003e （分支未合并的情况下） 切换分支 git checkout \u003c分支名\u003e 可以使用 git checkout -b \u003c分支\u003e创建分支并自动切换到到新创建的分支 合并分支 git merge \u003c分支名\u003e ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:3:1","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"储存当前工作空间 储存当前工作空间 git stash 查看存储的工作空间记录 git stach list 恢复工作空间 git stach apply 恢复后不会删除stach内容，需使用 git stach drop 来删除 恢复工作空间 git stach pop 恢复stach，并且把stach内容也删除 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/:3:2","tags":[],"title":"Git笔记","uri":"https://yangfengfan.dev/git%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"1.Android透明度 Android中的颜色值通常遵循RGB/ARGB标准，使用时通常以“#”字符开头，以16进制表示。常用的颜色值格式为： #RGB #ARGB #RRGGBB #AARRGGBB 其中，ARGB 依次代表透明度（alpha）、红色(red)、绿色(green)、蓝色(blue)。以颜色值 #FF99CC00 为例，其中，FF 是透明度，99 是红色值， CC 是绿色值， 00 是蓝色值。 透明度的取值范围为0-255，值越小越透明，透明度 （透明）0 –\u003e 255（不透明） 对应着16进制 00（透明） –\u003e FF（不透明）。比如：128表示50%的透明度，转换成16进制就是7F,说以黑色透明度50%就是 #7F000000. ","date":"2019-04-25","objectID":"https://yangfengfan.dev/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":[],"title":"学习笔记","uri":"https://yangfengfan.dev/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"常用透明度 透明度 16进制值 0% FF 10% E6 20% cc 30% B3 40% 99 50% 80 60% 66 70% 4D 80% 33 90% 1A 100% 00 ","date":"2019-04-25","objectID":"https://yangfengfan.dev/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":[],"title":"学习笔记","uri":"https://yangfengfan.dev/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":[],"content":"1.安装 Jekyll Writer 到 http://jekyllwriter.com/ 下载安装 Jekyll Writer，支持Windows、Mac和Linux三平台。Windows是绿色版。 ","date":"2019-04-24","objectID":"https://yangfengfan.dev/%E4%BD%BF%E7%94%A8jekyll-writer/:1:0","tags":[],"title":"使用Jekyll Writer","uri":"https://yangfengfan.dev/%E4%BD%BF%E7%94%A8jekyll-writer/"},{"categories":[],"content":"2.配置github账号 打开解压后的Jekyll Writer，在Account-\u003eGithub中配置token。 ","date":"2019-04-24","objectID":"https://yangfengfan.dev/%E4%BD%BF%E7%94%A8jekyll-writer/:2:0","tags":[],"title":"使用Jekyll Writer","uri":"https://yangfengfan.dev/%E4%BD%BF%E7%94%A8jekyll-writer/"},{"categories":[],"content":"3.获取Github的 personal access token 到你的 https://github.com/settings/tokens/new 页面创建访问的token。 Token description：简单描述一下这个 personal access token，填写无要求。 Select scopes：里面给这个token分配权限，你可以根据自己的情况给与权限 将你生成的token填写到Jekyll Write中，Jekyll Write会自动扫描你GitHub中的Jekyll仓库。 ","date":"2019-04-24","objectID":"https://yangfengfan.dev/%E4%BD%BF%E7%94%A8jekyll-writer/:3:0","tags":[],"title":"使用Jekyll Writer","uri":"https://yangfengfan.dev/%E4%BD%BF%E7%94%A8jekyll-writer/"},{"categories":[],"content":"4.开始写作 如上图，可以直接在这里面书写文章，点击PreView可以预览页面效果，点Publish就把文章提交到Github仓库发布出去了。遗憾的是不能插入本地图片，点击插入图片时只有网络链接、Dropbox和七牛，并不能插入本地图片，当我手动输入相对路径提交后还是不能显示 ","date":"2019-04-24","objectID":"https://yangfengfan.dev/%E4%BD%BF%E7%94%A8jekyll-writer/:4:0","tags":[],"title":"使用Jekyll Writer","uri":"https://yangfengfan.dev/%E4%BD%BF%E7%94%A8jekyll-writer/"},{"categories":[],"content":"1.问题 跟后台交互的时候，发现传过去的数据中有个 \\u003d 这是我传的参数 : query=[{property:“chengShi.id”,operator:“=”,value:1}] 这是后台接收到的参数： query=[{“property”:“chengShi.id”,“value”:1,“operator”:\"\\u003d”}] 很明显，是 = 出错了，因为要传的是对象，我把它封装在Map中了，再用Gson转换，这是我的代码： Map query = new HashMap(); query.put(\"property\", \"shangPinDM\"); query.put(\"operator\", \"=\"); query.put(\"value\", id); OkHttpGo.\u003cString\u003epost(API.CHECK_PRODUCT) .params(\"query\", \"[\" + MyJson.toJson(query) + \"]\") .execute(new DialogCallback\u003cString\u003e(this)....... 注意这段代码 MyJson.toJson(query)，MyJson中封装的是Gson。所以问题就出在Gson转换过程中。 ","date":"2019-03-14","objectID":"https://yangfengfan.dev/u003%E4%B9%B1%E7%A0%81/:1:0","tags":[],"title":"\\u003d乱码","uri":"https://yangfengfan.dev/u003%E4%B9%B1%E7%A0%81/"},{"categories":[],"content":"2. 原因 Gson默认是进行HTML ESCAPE,也就是转码， 比如我们 \\t 表示换行符。因此对象中有=时，Gson就会把=转码，而 = 转码就是 \\u003d 。如下图，使用站长之家的在线转换工具可以看到 = 转成Unicode编码之后就是 \\u003d ","date":"2019-03-14","objectID":"https://yangfengfan.dev/u003%E4%B9%B1%E7%A0%81/:2:0","tags":[],"title":"\\u003d乱码","uri":"https://yangfengfan.dev/u003%E4%B9%B1%E7%A0%81/"},{"categories":[],"content":"3.解决 既然Gson默认会进行HTML ESCAPE（转码），我们设置不让Gson转码就可以了，具体代码如下： // 创建一个不进行HtmlEscaping的Gson对象 Gson gson = new GsonBuilder().disableHtmlEscaping().create(); String json = gson.toJson(query); ","date":"2019-03-14","objectID":"https://yangfengfan.dev/u003%E4%B9%B1%E7%A0%81/:3:0","tags":[],"title":"\\u003d乱码","uri":"https://yangfengfan.dev/u003%E4%B9%B1%E7%A0%81/"},{"categories":[],"content":"1.问题 在library module中对监听的控件使用switch控制中，发现会报 Resource IDs cannot be used in a switch statement in Android library modules，翻译过来就是 资源ID不能在安卓库模块的switch语句中使用，之前这样写没有问题啊。 ","date":"2019-03-12","objectID":"https://yangfengfan.dev/resource-ids-cannot-be-used-in-a-switch-statement-in-android-library-modules/:1:0","tags":[],"title":"Resource IDs cannot be used in a switch statement in Android library modules","uri":"https://yangfengfan.dev/resource-ids-cannot-be-used-in-a-switch-statement-in-android-library-modules/"},{"categories":[],"content":"2.原因 查了一下发现原因是在library module中资源ID类型不是final类型的，主model中资源ID是final类型的。 ","date":"2019-03-12","objectID":"https://yangfengfan.dev/resource-ids-cannot-be-used-in-a-switch-statement-in-android-library-modules/:2:0","tags":[],"title":"Resource IDs cannot be used in a switch statement in Android library modules","uri":"https://yangfengfan.dev/resource-ids-cannot-be-used-in-a-switch-statement-in-android-library-modules/"},{"categories":[],"content":"3.解决方法 把switch语句换成if - else 语句。 if (view.getId() == R.id.iv_lib_main_commodity) { // if statement } else { // else statement } ","date":"2019-03-12","objectID":"https://yangfengfan.dev/resource-ids-cannot-be-used-in-a-switch-statement-in-android-library-modules/:3:0","tags":[],"title":"Resource IDs cannot be used in a switch statement in Android library modules","uri":"https://yangfengfan.dev/resource-ids-cannot-be-used-in-a-switch-statement-in-android-library-modules/"},{"categories":[],"content":"4.笔记 为什么这样做： Android 中，如果你在 module 中添加了一个资源，就拿这里的activity_main.xml 举例。我们此处假设如果在 module 中也是 final 的，那会出现什么情况？第一，该 module 编译后的代码中该资源会被替换成值；第二，当该 module 被添加到主项目中后，如果主项目中有一个同样名称的资源，那么 module 中的该资源就会被替换；第三，主项目中会重新针对该资源生成一个 ID；最终就会出现 module 中那个资源 ID 找不到了。所以呢，这也是为什么 module 中的资源 ID 声明不使用 final 的原因。 有关资源合并的规则，可以参考下 google 的官方文档 https://developer.android.com/studio/write/add-resources.html。 导致的几个现象 1，这就是为什么当主项目与 module 中有同样资源时，module 却会使用主项目的资源。 2，这也是为什么我们在 module 中无法针对资源使用 switch-case 方式的原因。 3，这也是为什么我们无法在 module 中直接使用 butterknife，因为注解的属性需要是 final 的。当然现在 butterknife 已经提供了一个解决方案。就是利用 gradle 拷贝一份 R.java 命名成 R2.java，R2.java 里面的资源声明都是 final 的。这样就躲过了语法检查。当然使用butterknife编译后的字节码中使用的还是R.java中的资源声明。 参考博客：https://juejin.im/post/5a98f240f265da23830a5193 ","date":"2019-03-12","objectID":"https://yangfengfan.dev/resource-ids-cannot-be-used-in-a-switch-statement-in-android-library-modules/:4:0","tags":[],"title":"Resource IDs cannot be used in a switch statement in Android library modules","uri":"https://yangfengfan.dev/resource-ids-cannot-be-used-in-a-switch-statement-in-android-library-modules/"},{"categories":[],"content":"一般使用分割线都是直线，今天看到一个使用虚线的，如下图，觉得比直线更美观。 ","date":"2019-03-11","objectID":"https://yangfengfan.dev/android%E8%99%9A%E7%BA%BF%E5%88%86%E5%89%B2%E7%BA%BF/:0:0","tags":[],"title":"Android虚线分割线","uri":"https://yangfengfan.dev/android%E8%99%9A%E7%BA%BF%E5%88%86%E5%89%B2%E7%BA%BF/"},{"categories":[],"content":"1.新建资源文件： 在res/drawable中新建bg_dot_line.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cshape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"line\"\u003e \u003cstroke android:width=\"1dp\" android:color=\"#eaeaea\" android:dashGap=\"5dp\" android:dashWidth=\"5dp\"/\u003e \u003c/shape\u003e ","date":"2019-03-11","objectID":"https://yangfengfan.dev/android%E8%99%9A%E7%BA%BF%E5%88%86%E5%89%B2%E7%BA%BF/:1:0","tags":[],"title":"Android虚线分割线","uri":"https://yangfengfan.dev/android%E8%99%9A%E7%BA%BF%E5%88%86%E5%89%B2%E7%BA%BF/"},{"categories":[],"content":"2.在布局文件中： \u003c!-- 虚线分割 --\u003e \u003cView android:layout_width=\"match_parent\" android:layout_height=\"2dp\" android:layerType=\"software\" android:background=\"@drawable/bg_dot_line\" /\u003e Viewde的背景使用我们刚才自定义的资源文件，需要注意的是 android:layerType=“software” 一定要写，否则显示的还是虚线。这个属性具体原理我也没弄明白，查了一下介绍这个的不多，讲的也是很不清楚，搞明白了再来更新。 ","date":"2019-03-11","objectID":"https://yangfengfan.dev/android%E8%99%9A%E7%BA%BF%E5%88%86%E5%89%B2%E7%BA%BF/:2:0","tags":[],"title":"Android虚线分割线","uri":"https://yangfengfan.dev/android%E8%99%9A%E7%BA%BF%E5%88%86%E5%89%B2%E7%BA%BF/"},{"categories":[],"content":"1.问题 使用Android Studio登陆Google账号时会跳转到浏览器登陆Google账号, 但是网页登录成功后Android Studio未响应 但是Android Studio一直停留在这个页面 2.原因 这是因为访问Google需要代理，而当我们请求登陆跳转到浏览器时使用的时系统正常请求，此时Android Studio在这个的端口等待浏览器返回状态。而我们访问Google网站使用了代理工具,登陆成功后Google把登陆成功状态返回到代理端口了，而Android Studio是在未代理的端口等待登陆状态，所以就会接收不到数据。 3.解决 我们把Android Studio的代理端口和系统请求端口设置为一样就行了。 首先找到我们代理工具，看看代理端口是多少，比如我使用的Shadowsocks代理端口时1080 然后打开Android Studio，在设置中把代理端口改成1080 然后再登陆就可以成功了 ","date":"2018-03-06","objectID":"https://yangfengfan.dev/android-studio%E7%99%BB%E5%BD%95google%E8%B4%A6%E5%8F%B7/:0:0","tags":[],"title":"Android Studio登录Google账号","uri":"https://yangfengfan.dev/android-studio%E7%99%BB%E5%BD%95google%E8%B4%A6%E5%8F%B7/"},{"categories":[],"content":"1.概述 从Android6.0开始，安卓的权限不在跟之前一样只要安装就有权限。在6.0之前如果权限在AndroidManifest.xml声明，只要安装就取得了这些权限，也就是说当你点击确定安装时就已经授权。在6.0以后权限不仅需要在AndroidManifest.xml中声明， 还需要在使用时动态申请，用户确认授权后才可以进行操作。 权限又分为普通权限和危险权限，如连接网络不会对用户隐私造成泄露的基本权限为正常权限， 如读取用户通讯录则是危险权限。只有危险权限才需要动态申请，普通权限可以跟之前一样只在AndroidManifes.xml中声明即可。 ","date":"2017-12-19","objectID":"https://yangfengfan.dev/android%E6%9D%83%E9%99%90%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7/:0:0","tags":[],"title":"Android权限动态申请","uri":"https://yangfengfan.dev/android%E6%9D%83%E9%99%90%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7/"},{"categories":[],"content":"1.1危险权限 group:android.permission-group.CONTACTS permission:android.permission.WRITE_CONTACTS permission:android.permission.GET_ACCOUNTS permission:android.permission.READ_CONTACTS group:android.permission-group.PHONE permission:android.permission.READ_CALL_LOG permission:android.permission.READ_PHONE_STATE permission:android.permission.CALL_PHONE permission:android.permission.WRITE_CALL_LOG permission:android.permission.USE_SIP permission:android.permission.PROCESS_OUTGOING_CALLS permission:com.android.voicemail.permission.ADD_VOICEMAIL group:android.permission-group.CALENDAR permission:android.permission.READ_CALENDAR permission:android.permission.WRITE_CALENDAR group:android.permission-group.CAMERA permission:android.permission.CAMERA group:android.permission-group.SENSORS permission:android.permission.BODY_SENSORS group:android.permission-group.LOCATION permission:android.permission.ACCESS_FINE_LOCATION permission:android.permission.ACCESS_COARSE_LOCATION group:android.permission-group.STORAGE permission:android.permission.READ_EXTERNAL_STORAGE permission:android.permission.WRITE_EXTERNAL_STORAGE group:android.permission-group.MICROPHONE permission:android.permission.RECORD_AUDIO group:android.permission-group.SMS permission:android.permission.READ_SMS permission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMS permission:android.permission.RECEIVE_SMS permission:android.permission.SEND_SMS permission:android.permission.READ_CELL_BROADCASTS group下面的同属于一个权限组。Android系统对所有的危险权限进行了分组，称为权限组 。属于同一组的危险权限将自动合并授予，用户授予应用某个权限组的权限，则应用将获得该权限组下的所有权限（前提是相关权限在 AndroidManifest.xml 中有声明） ","date":"2017-12-19","objectID":"https://yangfengfan.dev/android%E6%9D%83%E9%99%90%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7/:1:0","tags":[],"title":"Android权限动态申请","uri":"https://yangfengfan.dev/android%E6%9D%83%E9%99%90%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7/"},{"categories":[],"content":"1.2普通权限 android.permission.ACCESS_LOCATION_EXTRA_COMMANDS android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_NOTIFICATION_POLICY android.permission.ACCESS_WIFI_STATE android.permission.ACCESS_WIMAX_STATE android.permission.BLUETOOTH android.permission.BLUETOOTH_ADMIN android.permission.BROADCAST_STICKY android.permission.CHANGE_NETWORK_STATE android.permission.CHANGE_WIFI_MULTICAST_STATE android.permission.CHANGE_WIFI_STATE android.permission.CHANGE_WIMAX_STATE android.permission.DISABLE_KEYGUARD android.permission.EXPAND_STATUS_BAR android.permission.FLASHLIGHT android.permission.GET_ACCOUNTS android.permission.GET_PACKAGE_SIZE android.permission.INTERNET android.permission.KILL_BACKGROUND_PROCESSES android.permission.MODIFY_AUDIO_SETTINGS android.permission.NFC android.permission.READ_SYNC_SETTINGS android.permission.READ_SYNC_STATS android.permission.RECEIVE_BOOT_COMPLETED android.permission.REORDER_TASKS android.permission.REQUEST_INSTALL_PACKAGES android.permission.SET_TIME_ZONE android.permission.SET_WALLPAPER android.permission.SET_WALLPAPER_HINTS android.permission.SUBSCRIBED_FEEDS_READ android.permission.TRANSMIT_IR android.permission.USE_FINGERPRINT android.permission.VIBRATE android.permission.WAKE_LOCK android.permission.WRITE_SYNC_SETTINGS com.android.alarm.permission.SET_ALARM com.android.launcher.permission.INSTALL_SHORTCUT com.android.launcher.permission.UNINSTALL_SHORTCUT 普通权限只要在AndroidManifest中声明就行 2.申请权限 public class Permission extends Activity { private final static int PREMISSION_REQUESTCONTACTS_CODE = 100; /**读取通讯录权限申请码**/ private Button btu; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission); init(); } private void init() { btu = findViewById(R.id.button); btu.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { checkPermission(); } }); } /** * 读取通讯录 */ private void readContacts() { //读取通讯录... } /** * 6.0以上版本权限检查 */ private void checkPermission() { if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.M) { /**6.0以上才需要检查**/ /** * 检查读取通讯录权限 */ if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { /** * 如果没有授权就进行权限申请 * @param String[] permissions -可以把一组权限放一起申请 * @param int requestCode -本次申请的一个识别码，自定义，如果该类中有多次调用 *这个函数申请， 则调用时的requestCode不能相同。 否则无法识别是哪次申请 */ requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, PREMISSION_REQUESTCONTACTS_CODE); } else { /**已经有权限就可以读取了**/ readContacts(); } } else { /**6.0以下版本不需要检查,可以直接读取**/ readContacts(); } } /**** * 申请权限的回掉方法 * @param requestCode 请求权限时传入的请求码，用于区别是哪一次请求的 * @param permissions String[] permissions 所请求的所有权限的数组 * @param grantResults 权限授予结果，和 permissions 数组参数中的权限一一对应，元素值为 * 两种情况， 授予: PackageManager.PERMISSION_GRANTED * 拒绝: PackageManager.PERMISSION_DENIED */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { switch (requestCode) { /***访问通讯录权限***/ case PREMISSION_REQUESTCONTACTS_CODE: if (grantResults.length \u003e 0 \u0026\u0026 grantResults[0] == PackageManager.PERMISSION_GRANTED) { //同意权限 //同意了 readContacts(); } else { //拒绝权限 Toast.makeText(this, \"没有读取通讯录的权限\", Toast.LENGTH_SHORT).show(); } break; } } } 上面是一个读取用户通讯录的例子，其中有两个重要的方法 申请 public final void requestPermissions(String[] permissions, int requestCode) 回调 void onRequestPermissionsResult(int requestCode,String[] permissions, int[] grantResults) ","date":"2017-12-19","objectID":"https://yangfengfan.dev/android%E6%9D%83%E9%99%90%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7/:2:0","tags":[],"title":"Android权限动态申请","uri":"https://yangfengfan.dev/android%E6%9D%83%E9%99%90%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7/"},{"categories":[],"content":"1.下载Subversion 下载subversion yum install Subversion 确定安装 安装完成后查看SVN版本 svnserve --version 现在已经安装成功了。 ","date":"2017-11-27","objectID":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":[],"title":"CentOS搭建SVN服务器","uri":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":[],"content":"2. 创建SVN仓库 选择一个文件夹存放SVN仓库，我这里选择repository文件夹存放我们的SVＮ仓库 创建一个名为android的仓库 svnadmin create android 这个android文件夹就是我们的SVN仓库了，仓库的配置在conf文件夹下 svnserve.conf　仓库的配置 psswd　设置账号密码 authz　设置账号的权限 ","date":"2017-11-27","objectID":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":[],"title":"CentOS搭建SVN服务器","uri":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":[],"content":"2.1 svnserve.conf 把图中标记的注释(#)去除 anon-access: 控制非鉴权用户访问版本库的权限，取值范围为\"write”、“read\"和\"none”。 即\"write\"为可读可写，“read\"为只读，“none\"表示无访问权限。 默认值：read auth-access: 控制鉴权用户访问版本库的权限。取值范围为\"write”、“read\"和\"none”。 即\"write\"为可读可写，“read\"为只读，“none\"表示无访问权限。 默认值：write authz-db: 指定权限配置文件名，通过该文件可以实现以路径为基础的访问控制。 除非指定绝对路径，否则文件位置为相对conf目录的相对路径。 默认值：authz realm: 指定版本库的认证域，即在登录时提示的认证域名称。若两个版本库的 认证域相同，建议使用相同的用户名口令数据文件。 默认值：一个UUID(Universal Unique IDentifier，全局唯一标示)。 ","date":"2017-11-27","objectID":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:1","tags":[],"title":"CentOS搭建SVN服务器","uri":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":[],"content":"2.2. passwd 因为上面配置svnserve.conf是指定的是 password-db = passwd所以此passwd文件用来设置用户。 格式为 \u003c用户名\u003e = \u003c密码\u003e 如图我分配了一个账号为yff密码为123456的用户。 ","date":"2017-11-27","objectID":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:2","tags":[],"title":"CentOS搭建SVN服务器","uri":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":[],"content":"2.3. authz 因为上面配置svnserve.conf是指定的是 authz-db = authz所以此authz文件设置用户。该配置文件由一个[groups]配置段和若干个版本库路径权限段组成。 [groups]下设置用户组 [/] 或 [repository:/]等都是仓库的目录，在每个目录下配置该目录的用户权限。（用户需要在passwd中分配，权限有 ' ‘无访问权限 ‘r’读 ‘w’写） 如图yff账户在根目录下有读写的权限 ","date":"2017-11-27","objectID":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:3","tags":[],"title":"CentOS搭建SVN服务器","uri":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":[],"content":"3.启动SVN服务 启动命令为 svnserve -d -r \u003c仓库目录\u003e 如 svnserve -d -r /home/svn/ 注意：由于启动目录的不同，可分为两种启动模式 ","date":"2017-11-27","objectID":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:0","tags":[],"title":"CentOS搭建SVN服务器","uri":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":[],"content":"1. 单库模式 比如我们android仓库的完整路径为/home/svn/android 。如果我们启动命令为svnserve -d -r /home/svn/android这种方式启动，那么svnserve只能这一个android仓库工作，即CentOS的/home/svn/android/目录。我们访问时通过 svn://ip 就可以直接连接到android仓库 ","date":"2017-11-27","objectID":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:1","tags":[],"title":"CentOS搭建SVN服务器","uri":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":[],"content":"2. 多库模式 如果启动的时候用的是svnserve -d -r /home/svn，则/home/svn下面的所有仓库都是可以访问的，这时访问android创库则要通过 svn://ip/android 如果/home/svn下还有一个web仓库，如/home/svn/web则访问web仓库使用svn://ip/web 即启动目录就是我们ip定位到的服务器路径 ","date":"2017-11-27","objectID":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:2","tags":[],"title":"CentOS搭建SVN服务器","uri":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":[],"content":"4. 关闭 如果要关闭SVN使用 killall svnserve ","date":"2017-11-27","objectID":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:0","tags":[],"title":"CentOS搭建SVN服务器","uri":"https://yangfengfan.dev/centos%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]